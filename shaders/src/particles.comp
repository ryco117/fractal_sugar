#version 450

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) buffer PositionBuffer {
	vec2 positions[];
};
layout (binding = 1) buffer VelocityBuffer {
	vec2 velocities[];
};
layout (binding = 2) buffer readonly FixedPosBuffer {
	vec2 fixedPositions[];
};

layout (push_constant) uniform Push
{
	vec2 bigBoomer;
	vec2 curlAttractors[2];
	vec2 attractors[2];

	float bigBoomerStrength;
	float curlAttractorStrengths[2];
	float attractorStrengths[2];

	float time;
	float deltaTime;
	bool fixParticles;
} push;

const float springCoefficient = 150.0;

const float maxSpeed = 6.0;
const float min_length = 0.01;
const float friction = -3.0;

const float audioScale = 0.01;

vec2 Normalize(vec2 t) {
	if(length(t) < 0.000001) {
		return t;
	}
	return normalize(t);
}

void main(void)
{
	const uint index = gl_GlobalInvocationID.x;

	// Read the current position and velocity from the buffers
	vec2 pos = positions[index];
	vec2 vel = velocities[index];
	
	vec2 g = vec2(0.0);
	{
		vec2 t = push.bigBoomer - pos;
		float r = max(length(t), min_length);
		g -= push.bigBoomerStrength * Normalize(t) / (r*r*r)  * (push.fixParticles ? 0.35 : 0.5);
	}

	for(int i = 0; i < push.curlAttractors.length(); i++)
	{
		vec2 t = push.curlAttractors[i] - pos;
		float r = max(length(t), min_length);
		g += push.curlAttractorStrengths[i] * Normalize(vec2(-t.y, t.x)) / (r*r) * (push.fixParticles ? 2.0 : 3.0);
	}

	for(int i = 0; i < push.attractors.length(); i++)
	{
		vec2 t = push.attractors[i] - pos;
		float r = max(length(t), min_length);
		g += push.attractorStrengths[i] * Normalize(t) / (r*r) * (push.fixParticles ? 3.5 : 5.0);
	}

	g *= audioScale;

	if(push.fixParticles) {
		g += springCoefficient * (fixedPositions[index] - pos);
	}

	vel += push.deltaTime * g;
	
	if(length(vel) > maxSpeed) {
		vel = maxSpeed*normalize(vel);
	}

	pos += vel * push.deltaTime;
	if(abs(pos.x) > 1.0) {
		vel.x = sign(pos.x) * (-0.95 * abs(vel.x) - 0.0001);
		if(abs(pos.x) >= 1.05) {
			pos.x = sign(pos.x);
		}
	}
	if(abs(pos.y) > 1.0) {
		vel.y = sign(pos.y) * (-0.95 * abs(vel.y) - 0.0001);
		if(abs(pos.y) >= 1.05) {
			pos.y = sign(pos.y);
		}
	}

	positions[index] = pos;
	velocities[index] =  vel * exp(friction * push.deltaTime);
}